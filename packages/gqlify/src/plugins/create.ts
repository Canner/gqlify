import Model from '../dataModel/model';
import { Context, Plugin } from './interface';
import WhereInputPlugin from './whereInput';
import BaseTypePlugin from './baseType';
import ObjectField from '../dataModel/objectField';
import { upperFirst, forEach, get } from 'lodash';
import { ListMutable } from '../dataSource/interface';
import { RelationField } from '../dataModel';
import { Hook, CreateContext } from '../hooks/interface';

const createObjectInputField = (prefix: string, field: ObjectField, context: Context) => {
  const { root } = context;
  const content: string[] = [];
  forEach(field.getFields(), (nestedField, name) => {
    if (nestedField.isScalar()) {
      content.push(`${name}: ${nestedField.getTypename()}`);
      return;
    }

    if (nestedField instanceof ObjectField) {
      const fieldWithPrefix = `${prefix}${upperFirst(name)}`;
      const typeFields = createObjectInputField(fieldWithPrefix, nestedField, context);
      const objectInputName = `${fieldWithPrefix}CreateInput`;
      root.addInput(`input ${objectInputName} {${typeFields.join(' ')}}`);
      content.push(`${name}: ${objectInputName}`);
      return;
    }

    // skip relation, dont support relation in nested object for now
  });
  return content;
};

const createInputField = (
  model: Model,
  context: Context,
  createInputName: string,
  getWhereInputName: (model: Model) => string,
  getWhereUniqueInputName: (model: Model) => string,
) => {
  const { root } = context;
  const capName = model.getNamings().capitalSingular;
  const fields = model.getFields();
  const content: string[] = [];
  forEach(fields, (field, name) => {
    if (field.isAutoGenerated()) {
      return;
    }

    if (field.isScalar()) {
      const fieldType = field.isList() ? `[${field.getTypename()}]` : field.getTypename();
      content.push(`${name}: ${fieldType}`);
      return;
    }

    if (field instanceof ObjectField) {
      // create input for nested object
      const fieldWithPrefix = `${capName}${upperFirst(name)}`;
      const typeFields = createObjectInputField(fieldWithPrefix, field, context);
      const objectInputName = `${fieldWithPrefix}CreateInput`;
      root.addInput(`input ${objectInputName} {${typeFields.join(' ')}}`);
      const fieldType = field.isList() ? `[${objectInputName}]` : objectInputName;
      content.push(`${name}: ${fieldType}`);
      return;
    }

    // relation
    // add create and connect for relation
    const isRelation = field instanceof RelationField;
    const isList = field.isList();
    if (isRelation && !isList) {
      // to-one
      const relationTo = (field as RelationField).getRelationTo();
      const relationInputName = `${capName}CreateOneInput`;
      root.addInput(`input ${relationInputName} {
        create: ${createInputName}
        connect: ${getWhereUniqueInputName(relationTo)}
      }`);
      content.push(`${name}: ${relationInputName}`);
      return;
    }

    if (isRelation && isList) {
      // to-many
      const relationTo = (field as RelationField).getRelationTo();
      const relationInputName = `${capName}CreateManyInput`;
      root.addInput(`input ${relationInputName} {
        create: [${createInputName}]
        connect: [${getWhereUniqueInputName(relationTo)}]
      }`);
      content.push(`${name}: ${relationInputName}`);
      return;
    }
  });

  return content;
};

export default class CreatePlugin implements Plugin {
  private whereInputPlugin: WhereInputPlugin;
  private baseTypePlugin: BaseTypePlugin;
  private hook: Hook;

  constructor({
    hook,
  }: {
    hook: Hook,
  }) {
    this.hook = hook;
  }

  public setPlugins(plugins: Plugin[]) {
    this.whereInputPlugin = plugins.find(
      plugin => plugin instanceof WhereInputPlugin) as WhereInputPlugin;
    this.baseTypePlugin = plugins.find(
      plugin => plugin instanceof BaseTypePlugin) as BaseTypePlugin;
  }

  public visitModel(model: Model, context: Context) {
    const { root } = context;
    const modelType = this.baseTypePlugin.getTypename(model);

    // create
    const mutationName = this.getMutationName(model);
    const inputName = this.generateCreateInput(model, context);
    root.addMutation(`${mutationName}(data: ${inputName}!): ${modelType}`);
  }

  public resolveInMutation({model, dataSource}: {model: Model, dataSource: ListMutable}) {
    const mutationName = this.getMutationName(model);
    const wrapCreate = get(this.hook, [model.getName(), 'wrapCreate']);

    return {
      [mutationName]: async (root, args, context) => {
        if (!wrapCreate) {
          return dataSource.create(args.data);
        }

        // wrap
        const createContext: CreateContext = {data: args.data, response: {}};
        await wrapCreate(createContext, async ctx => {
          ctx.response = await dataSource.create(ctx.data);
        });
        return createContext.response;
      },
    };
  }

  public getCreateInputName(model: Model) {
    return `${model.getNamings().capitalSingular}CreateInput`;
  }

  private generateCreateInput(model: Model, context: Context) {
    const inputName = this.getCreateInputName(model);
    const input = `input ${inputName} {
      ${createInputField(
        model,
        context,
        inputName,
        this.whereInputPlugin.getWhereInputName,
        this.whereInputPlugin.getWhereUniqueInputName,
      )}
    }`;
    context.root.addInput(input);
    return inputName;
  }

  private getMutationName(model: Model) {
    return `create${model.getNamings().capitalSingular}`;
  }
}
