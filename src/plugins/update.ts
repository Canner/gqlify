import Model from '../dataModel/model';
import { Context, Plugin } from './interface';
import WhereInputPlugin from './whereInput';
import BaseTypePlugin from './baseType';
import ObjectField from '../dataModel/objectField';
import { upperFirst, forEach, get } from 'lodash';
import { ListMutable } from '../dataSource/interface';

const createObjectInputField = (prefix: string, field: ObjectField, context: Context) => {
  const { root } = context;
  const content: string[] = [];
  forEach(field.getFields(), (nestedField, name) => {
    if (nestedField.isScalar()) {
      content.push(`${name}: ${nestedField.getTypename()}`);
      return;
    }

    if (nestedField instanceof ObjectField) {
      const fieldWithPrefix = `${prefix}${upperFirst(name)}`;
      const typeFields = createObjectInputField(fieldWithPrefix, nestedField, context);
      const objectInputName = `${fieldWithPrefix}UpdateInput`;
      root.addInput(`input ${objectInputName} {${typeFields.join(' ')}}`);
      content.push(`${name}: ${objectInputName}`);
      return;
    }

    // skip relation field
  });
  return content;
};

const createInputField = (model: Model, context: Context) => {
  const { root } = context;
  const fields = model.getFields();
  const content: string[] = [];
  forEach(fields, (field, name) => {
    if (field.isAutoGenerated()) {
      return;
    }

    if (field.isScalar()) {
      content.push(`${name}: ${field.getTypename()}`);
      return;
    }

    if (field instanceof ObjectField) {
      // create input for nested object
      const fieldWithPrefix = `${model.getNamings().capitalSingular}${upperFirst(name)}`;
      const typeFields = createObjectInputField(fieldWithPrefix, field, context);
      const objectInputName = `${fieldWithPrefix}UpdateInput`;
      root.addInput(`input ${objectInputName} {${typeFields.join(' ')}}`);
      content.push(`${name}: ${field.getTypename()}`);
      return;
    }

    // todo: add relation
  });

  return content;
};

export default class UpdatePlugin implements Plugin {
  private whereInputPlugin: WhereInputPlugin;
  private baseTypePlugin: BaseTypePlugin;
  private beforeUpdate?: Record<string, (where: any, data: Record<string, any>) => Promise<void>>;
  private transformPayload?: Record<string, (data: Record<string, any>) => Promise<Record<string, any>>>;
  private afterUpdate?: Record<string, (where: any, data: Record<string, any>) => Promise<void>>;

  constructor({
    beforeUpdate,
    transformPayload,
    afterUpdate,
  }: {
    beforeUpdate?: Record<string, (where: any, data: Record<string, any>) => Promise<void>>,
    transformPayload?: Record<string, (data: Record<string, any>) => Promise<Record<string, any>>>,
    afterUpdate?: Record<string, (where: any, data: Record<string, any>) => Promise<void>>,
  }) {
    this.beforeUpdate = beforeUpdate;
    this.transformPayload = transformPayload;
    this.afterUpdate = afterUpdate;
  }

  public setPlugins(plugins: Plugin[]) {
    this.whereInputPlugin = plugins.find(
      plugin => plugin instanceof WhereInputPlugin) as WhereInputPlugin;
    this.baseTypePlugin = plugins.find(
      plugin => plugin instanceof BaseTypePlugin) as BaseTypePlugin;
  }

  public visitModel(model: Model, context: Context) {
    const { root } = context;
    const modelType = this.baseTypePlugin.getTypename(model);

    // update
    const mutationName = this.getInputName(model);
    const inputName = this.generateUpdateInput(model, context);
    const whereUniqueInput = this.whereInputPlugin.getWhereUniqueInputName(model);
    root.addMutation(`${mutationName}(where: ${whereUniqueInput}, data: ${inputName}!): ${modelType}`);
  }

  public resolveInMutation({model, dataSource}: {model: Model, dataSource: ListMutable}) {
    const mutationName = this.getInputName(model);
    const beforeCreate = get(this.beforeUpdate, model.getName());
    const transformPayload = get(this.transformPayload, model.getName());
    const afterCreate = get(this.afterUpdate, model.getName());

    return {
      [mutationName]: async (root, args, context) => {
        const whereUnique = this.whereInputPlugin.parseUniqueWhere(args.where);
        if (beforeCreate) {
          await beforeCreate(whereUnique, args.data);
        }
        const data = transformPayload ? await transformPayload(args.data) : args.data;
        const updated = await dataSource.update(whereUnique, data);
        if (afterCreate) {
          await afterCreate(whereUnique, data);
        }
        return updated;
      },
    };
  }

  private generateUpdateInput(model: Model, context: Context) {
    const inputName = `${model.getNamings().capitalSingular}UpdateInput`;
    const input = `input ${inputName} {
      ${createInputField(model, context)}
    }`;
    context.root.addInput(input);
    return inputName;
  }

  private getInputName(model: Model) {
    return `update${model.getNamings().capitalSingular}`;
  }
}
